from fractions import Fraction
from typing import Callable

from PIL import Image, ImageDraw, ImageColor

import common
from bfs_for_pythagorea import get_points_in_one_lines_set
from geo import Point, Line


def draw_result(fig, target_point: Point, init_figure, grid_size):
    grid_pixels = 100
    line_width = 1
    margin = 10
    total_size = margin * 2 + grid_size * 2 * grid_pixels + line_width

    color_background = ImageColor.colormap["whitesmoke"]
    color_frame = ImageColor.colormap["darkgrey"]
    color_pre_line = ImageColor.colormap["darkred"]
    color_ans_line = ImageColor.colormap["darkblue"]
    color_key_point = ImageColor.colormap["yellow"]
    color_target_point = ImageColor.colormap["yellowgreen"]

    radius_key_point = 5

    img = Image.new('RGB', (total_size, total_size), color_background)
    draw = ImageDraw.Draw(img)

    line_top = Line(Fraction(0), Fraction(1), Fraction(-grid_size))
    line_bottom = Line(Fraction(0), Fraction(1), Fraction(+grid_size))
    line_left = Line(Fraction(1), Fraction(0), Fraction(-grid_size))
    line_right = Line(Fraction(1), Fraction(0), Fraction(+grid_size))
    frame = (line_top, line_bottom, line_left, line_right)

    def coord_in_img(p: Point):
        return margin + (p.x + 3) * grid_pixels, margin + (grid_size * 2 - p.y - 3) * grid_pixels

    point_checker: Callable[[Fraction, Fraction], bool] = common.POINT_CHECKER(grid_size)

    def draw_point(p):
        pos = coord_in_img(p)
        r = radius_key_point
        draw.ellipse((pos[0] - r, pos[1] - r, pos[0] + r, pos[1] + r),
                     color_target_point if p == target_point else color_key_point)

    def draw_line(line, color, width):
        points = set(line.get_cross_point(frame_line, point_checker) for frame_line in frame) - {None}
        points = tuple(points)
        draw.line([coord_in_img(points[0]), coord_in_img(points[1])], color, width)

    init_lines = [Line(ll[0], ll[1], ll[2]) for ll in init_figure]
    for line_ in init_lines:
        if (line_.a, line_.b) in ((0, 1), (1, 0)):  # integer vertical line and horizontal line, it's in the grid
            _color, _width = color_frame, 1
        else:
            _color, _width = color_pre_line, 2
        draw_line(line_, _color, _width)

    all_lines = init_lines[:]
    answer_lines = set([Line(ll[0], ll[1], ll[2]) for ll in fig])
    while answer_lines:
        all_points = get_points_in_one_lines_set(all_lines)
        for line_ in tuple(answer_lines):
            point_list = []
            for point in all_points:
                if line_.contain_point(point):
                    point_list.append(point)
                    if len(point_list) == 2:
                        break
            else:
                continue  # this line doesn't contain 2 found points
            assert len(point_list) >= 2
            draw_line(line_, color_ans_line, 3)
            draw_point(point_list[0])
            draw_point(point_list[1])
            answer_lines.remove(line_)
            break
        else:
            # no line be found that can be generated by 2 exist points.
            assert False
    draw_point(target_point)

    img.show()

    pass
